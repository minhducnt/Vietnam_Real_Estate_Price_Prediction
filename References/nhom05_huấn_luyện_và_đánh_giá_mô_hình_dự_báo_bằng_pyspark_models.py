# -*- coding: utf-8 -*-
"""Nhom05_Huấn_luyện_và_đánh_giá_mô_hình_dự_báo_bằng_PySpark_Models.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CGXC_fhqj5cMgaJMNAUP46a4Xkd5H94m
"""

from pyspark.sql.functions import col
from pyspark.sql.functions import mean
from pyspark.sql.types import DoubleType, IntegerType
from pyspark.ml.feature import StringIndexer, VectorAssembler
from pyspark.ml.regression import LinearRegression, DecisionTreeRegressor, RandomForestRegressor, GBTRegressor
from pyspark.ml import Pipeline
from pyspark.ml.evaluation import RegressionEvaluator
from pyspark.sql.functions import expm1
from pyspark.ml.feature import StringIndexer, OneHotEncoder, VectorAssembler, StandardScaler
from pyspark.ml.classification import GBTClassifier
from pyspark.ml.evaluation import MulticlassClassificationEvaluator
from google.colab import files
import shutil

import seaborn as sns
import matplotlib.pyplot as plt

"""#Import dữ liệu vào train model"""

# 1. Cài gdown để tải file từ Google Drive
!pip install -q gdown
# 2. Tải file về máy
!gdown --id 1somz0J_Co1-eQnNtp5heqMT1ynx78dgF -O dataset.csv

# 3. Import PySpark
from pyspark.sql import SparkSession
# 4. Tạo Spark session
spark = SparkSession.builder.appName("ImportCSV").getOrCreate()

# 5. Đọc file CSV vào Spark DataFrame
df = spark.read.option("header", True).csv("dataset.csv")
# 6. Hiển thị vài dòng đầu
df.show()

df.printSchema()



numerical_cols = ["area (m2)", "floor_num", "toilet_num", "livingroom_num","bedroom_num", "street (m)"]

#Ép kiểu dữ liệu
from pyspark.sql.functions import col

df = df.withColumn("price_per_m2", col("price_per_m2").cast("double")) \
       .withColumn("area (m2)", col("area (m2)").cast("double")) \
       .withColumn("floor_num", col("floor_num").cast("int")) \
       .withColumn("toilet_num", col("toilet_num").cast("int")) \
       .withColumn("livingroom_num", col("livingroom_num").cast("int")) \
       .withColumn("bedroom_num", col("bedroom_num").cast("int")) \
       .withColumn("street (m)", col("street (m)").cast("double"))

df.printSchema()

from pyspark.sql.functions import when, col
from pyspark.sql import DataFrame

def handle_missing_numeric_spark(df: DataFrame, columns: list) -> DataFrame:
    """
    Tạo flag + impute -1 bằng median cho các cột số trong PySpark.
    df: Spark DataFrame gốc
    columns: danh sách các cột cần xử lý
    """
    for col_name in columns:
        # Tạo cột flag báo thiếu
        missing_flag_col = f"{col_name}_missing_flag"
        df = df.withColumn(missing_flag_col, when(col(col_name) == -1, 1).otherwise(0))

        # Tính median bằng approxQuantile
        median_val = df.filter(col(col_name) != -1) \
                       .approxQuantile(col_name, [0.5], 0.01)[0]

        # Thay -1 bằng median
        df = df.withColumn(col_name, when(col(col_name) == -1, median_val).otherwise(col(col_name)))

    return df

cols_to_fix = ['bedroom_num', 'toilet_num', 'floor_num', 'livingroom_num']
df = handle_missing_numeric_spark(df, cols_to_fix)

df.printSchema()

binary_cols = ["bedroom_num_missing_flag", "toilet_num_missing_flag","floor_num_missing_flag","livingroom_num_missing_flag"]

# Lấy dữ liệu Pandas
df_pandas = df.select("price_per_m2").dropna().toPandas()
import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(10, 3))
sns.boxplot(x=df_pandas["price_per_m2"], orient="h")
plt.xscale("log")  # scale log cho dễ thấy outlier
plt.title("Boxplot - Outlier trong cột price_per_m2")
plt.xlabel("Giá (VND/m²)")
plt.tight_layout()
plt.show()

# Giữ lại chỉ những dòng có giá hợp lý (ví dụ: 1 triệu đến 1 tỷ VND/m²)
df = df.filter((col("price_per_m2") >= 2e6) & (col("price_per_m2") <= 1e8))

# Lấy dữ liệu Pandas
df_pandas = df.select("price_per_m2").dropna().toPandas()
plt.figure(figsize=(10, 3))
sns.boxplot(x=df_pandas["price_per_m2"], orient="h")
plt.xscale("log")  # scale log cho dễ thấy outlier
plt.title("Boxplot đã loại bỏ Outlier trong cột price_per_m2")
plt.xlabel("Giá (VND/m²)")
plt.tight_layout()
plt.show()

df.select("price_per_m2").summary().show()

from pyspark.sql.functions import log1p

df = df.withColumn("price_log", log1p(col("price_per_m2")))

df.count()

df.show()

"""#Xây dựng pipeline tiền xử lý"""

#StringIndexer → OneHotEncoder → VectorAssembler → Model

#One-Hot Encoding cho các cột phân loại
categorical_cols = ["category", "direction", "liability", "district", "city_province"]

# Step 1: StringIndexer
indexers = [
    StringIndexer(inputCol=col, outputCol=col + "_idx", handleInvalid="keep")
    for col in categorical_cols
]

# Step 2: OneHotEncoder
encoders = [
    OneHotEncoder(inputCol=col + "_idx", outputCol=col + "_vec")
    for col in categorical_cols
]

#Assemble tất cả các feature thành 1 vector
feature_cols = binary_cols + numerical_cols + [col + "_vec" for col in categorical_cols]
assembler = VectorAssembler(inputCols=feature_cols, outputCol="features")

# Scale features
scaler = StandardScaler(inputCol="features", outputCol="scaled_features", withMean=True, withStd=True)

# Combine tất cả vào pipeline
pipeline = Pipeline(stages=indexers + encoders + [assembler, scaler])

train_df, test_df = df.randomSplit([0.8, 0.2], seed=42)

train_df.printSchema()

# 2. Fit pipeline trên train data
pipeline_model = pipeline.fit(train_df)

# 3. Transform cả train và test với model đã fit
train_transformed = pipeline_model.transform(train_df)
test_transformed = pipeline_model.transform(test_df)

# Xem kết quả
train_transformed.select("scaled_features").show(truncate=False)

train_transformed.select("price_log").show(truncate=False)

test_transformed.printSchema()

"""#Train model

#Linear Regression
"""

lr = LinearRegression(featuresCol="scaled_features", labelCol="price_log")
lr_model = lr.fit(train_transformed)

lr_preds = lr_model.transform(test_transformed)

lr_preds = lr_preds.withColumn("predicted_price", expm1("prediction"))

lr_preds = lr_preds.withColumnRenamed("price_per_m2", "actual_price")

"""#Decision Tree Regression"""

dt = DecisionTreeRegressor(
    featuresCol="scaled_features",  # vector đầu vào
    labelCol="price_log"            # target đã log-transform
)

dt_model = dt.fit(train_transformed)

dt_preds = dt_model.transform(test_transformed)

dt_preds = dt_preds.withColumn("predicted_price", expm1("prediction"))

dt_preds = dt_preds.withColumnRenamed("price_per_m2", "actual_price")

"""#Random Forest Regression"""

rf = RandomForestRegressor(
    featuresCol="scaled_features",  # vector đầu vào
    labelCol="price_log",           # target đã log-transform
    numTrees=200,                   # số lượng cây
    maxDepth=8,                    # chiều sâu tối đa, tránh overfitting
    seed=42                         # cho kết quả reproducible
)

rf_model = rf.fit(train_transformed)

rf_preds = rf_model.transform(test_transformed)

rf_preds = rf_preds.withColumn("predicted_price", expm1("prediction"))
rf_preds = rf_preds.withColumnRenamed("price_per_m2", "actual_price")

"""#Gradient - Boosted Tree Regression

"""

gbt = GBTRegressor(
    featuresCol="scaled_features",   # vector đặc trưng đã chuẩn hóa
    labelCol="price_log",            # target đã log-transform
    maxIter=200,                     # số vòng boosting (trees)
    maxDepth=6,                      # độ sâu mỗi cây con
    seed=42
)

gbt_model = gbt.fit(train_transformed)

gbt_preds = gbt_model.transform(test_transformed)

gbt_preds = gbt_preds.withColumn("predicted_price", expm1("prediction"))
gbt_preds = gbt_preds.withColumnRenamed("price_per_m2", "actual_price")

"""#Đánh giá"""

def evaluate_model(pred_df, label_col="price_per_m2", prediction_col="prediction"):
    # Chuyển từ log → giá trị thật
    pred_df = pred_df.withColumn("predicted_price", expm1(prediction_col))

    # Đổi label thành giá trị thật nếu cần
    pred_df = pred_df.withColumnRenamed("price_per_m2", "actual_price")

    # Khởi tạo evaluator
    evaluator_rmse = RegressionEvaluator(labelCol="actual_price", predictionCol="predicted_price", metricName="rmse")
    evaluator_mse = RegressionEvaluator(labelCol="actual_price", predictionCol="predicted_price", metricName="mse")
    evaluator_mae = RegressionEvaluator(labelCol="actual_price", predictionCol="predicted_price", metricName="mae")
    evaluator_r2  = RegressionEvaluator(labelCol="actual_price", predictionCol="predicted_price", metricName="r2")

    return {
        "RMSE": evaluator_rmse.evaluate(pred_df),
        "MSE": evaluator_mse.evaluate(pred_df),
        "MAE": evaluator_mae.evaluate(pred_df),
        "R2": evaluator_r2.evaluate(pred_df)
    }

lr_metrics = evaluate_model(lr_preds)
dt_metrics = evaluate_model(dt_preds)
rf_metrics = evaluate_model(rf_preds)
gbt_metrics = evaluate_model(gbt_preds)

# In ra bảng so sánh
print("Đánh giá mô hình (trên giá trị thực tế - VND/m²):")
print(f"Linear Regression:       RMSE={lr_metrics['RMSE']:.2f}, MSE={lr_metrics['MSE']:.2f}, MAE={lr_metrics['MAE']:.2f}, R²={lr_metrics['R2']:.4f}")
print(f"Decision Tree:           RMSE={dt_metrics['RMSE']:.2f}, MSE={dt_metrics['MSE']:.2f}, MAE={dt_metrics['MAE']:.2f}, R²={dt_metrics['R2']:.4f}")
print(f"Random Forest:           RMSE={rf_metrics['RMSE']:.2f}, MSE={rf_metrics['MSE']:.2f}, MAE={rf_metrics['MAE']:.2f}, R²={rf_metrics['R2']:.4f}")
print(f"Gradient Boosted Tree:   RMSE={gbt_metrics['RMSE']:.2f}, MSE={gbt_metrics['MSE']:.2f}, MAE={gbt_metrics['MAE']:.2f}, R²={gbt_metrics['R2']:.4f}")

"""#Lưu trữ model cho lần sử dụng tiếp theo"""

# Đặt đường dẫn để lưu mô hình trong thư mục hiện tại của Colab
model_save_path = "/content/gbt_regressor_model"  # Thư mục tạm thời trên Colab
# Lưu mô hình vào đường dẫn
gbt_model.save(model_save_path)
print("Mô hình đã được lưu vào thư mục Colab tại:", model_save_path)

# Đặt đường dẫn đến thư mục bạn muốn nén
folder_path = '/content/gbt_regressor_model'
# Đặt đường dẫn lưu tệp nén
zip_path = '/content/gbt_regressor_model.zip'
# Nén thư mục thành tệp .zip
shutil.make_archive(zip_path.replace('.zip', ''), 'zip', folder_path)
print(f"Thư mục đã được nén thành {zip_path}")

# Tải tệp nén về máy tính
files.download(zip_path)
print(f"Tệp {zip_path} đã được tải xuống máy tính.")