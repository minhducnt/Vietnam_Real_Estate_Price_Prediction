import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from folium.plugins import HeatMap
import plotly.express as px
import plotly.graph_objects as go
from pyspark.sql import SparkSession
from pyspark.ml.feature import VectorAssembler, StandardScaler
from pyspark.ml.regression import GBTRegressor, GBTRegressionModel
from pyspark.ml import Pipeline, PipelineModel
from pyspark.ml.evaluation import RegressionEvaluator
import os
import pickle
import random
import time
import subprocess
from pyngrok import ngrok

# Kh·ªüi t·∫°o bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u t√™n c·ªôt
FEATURE_COLUMNS = {
    'area': 'area (m2)',
    'street': 'street (m)'
}

# Thi·∫øt l·∫≠p trang v·ªõi giao di·ªán hi·ªán ƒë·∫°i
st.set_page_config(
    page_title="D·ª± ƒêo√°n Gi√° B·∫•t ƒê·ªông S·∫£n Vi·ªát Nam",
    page_icon="üè†",
    layout="wide",
    initial_sidebar_state="expanded"
)

# CSS t√πy ch·ªânh ƒë·ªÉ t·∫°o giao di·ªán hi·ªán ƒë·∫°i
st.markdown('''
<style>
    .main {
        background-color: #f8f9fa;
    }
    .stApp {
        font-family: 'Roboto', sans-serif;
    }
    .stTabs [data-baseweb="tab-list"] {
        gap: 10px;
    }
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        white-space: pre-wrap;
        background-color: #f1f3f4;
        border-radius: 5px 5px 0px 0px;
        gap: 1px;
        padding-top: 10px;
        padding-bottom: 10px;
    }
    .stTabs [aria-selected="true"] {
        background-color: #4c9aff;
        color: white;
    }
    .stButton>button {
        background-color: #4c9aff;
        color: white;
        border-radius: 5px;
        border: none;
        padding: 10px 20px;
        font-weight: 500;
    }
    .stButton>button:hover {
        background-color: #3d7ecc;
        color: white;
    }
    div[data-testid="stMetricValue"] {
        font-size: 1.5rem;
        font-weight: bold;
    }
    div[data-testid="stMetricLabel"] {
        font-size: 1rem;
    }
    .card {
        background-color: white;
        border-radius: 10px;
        padding: 20px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
    }
</style>
''', unsafe_allow_html=True)

# Kh·ªüi t·∫°o phi√™n Spark
@st.cache_resource
def get_spark_session():
    """Kh·ªüi t·∫°o v√† tr·∫£ v·ªÅ m·ªôt phi√™n Spark."""
    return (
        SparkSession.builder
        .appName("VNRealEstatePricePrediction")
        .config("spark.driver.memory", "2g")
        .master("local[*]")
        .getOrCreate()
    )

# ƒê·ªçc d·ªØ li·ªáu
@st.cache_data
def load_data(file_path="../Data/Final Data Cleaned.csv"):
    """ƒê·ªçc d·ªØ li·ªáu b·∫•t ƒë·ªông s·∫£n t·ª´ file CSV."""
    try:
        # ƒê·ªçc d·ªØ li·ªáu b·∫±ng pandas
        df = pd.read_csv(file_path)
        return df
    except Exception as e:
        st.error(f"L·ªói khi ƒë·ªçc d·ªØ li·ªáu: {e}")
        return pd.DataFrame()

@st.cache_data
def preprocess_data(data):
    """Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu cho ph√¢n t√≠ch v√† m√¥ h√¨nh h√≥a."""
    # T·∫°o b·∫£n sao ƒë·ªÉ tr√°nh c·∫£nh b√°o c·ªßa Pandas
    df = data.copy()

    # ƒê·ªïi t√™n c·ªôt ƒë·ªÉ d·ªÖ s·ª≠ d·ª•ng (n·∫øu ch∆∞a c√≥)
    column_mapping = {
        'area (m2)': 'area_m2',
        'street (m)': 'street_width_m'
    }

    # Ki·ªÉm tra v√† ƒë·ªïi t√™n c·ªôt n·∫øu c·∫ßn
    for old_name, new_name in column_mapping.items():
        if old_name in df.columns and new_name not in df.columns:
            df[new_name] = df[old_name]

    # X·ª≠ l√Ω gi√° tr·ªã thi·∫øu
    numeric_cols = ["area_m2", "bedroom_num", "floor_num", "toilet_num", "livingroom_num", "street_width_m"]
    for col in numeric_cols:
        if col in df:
            # Thay th·∫ø -1 (gi√° tr·ªã thi·∫øu) b·∫±ng gi√° tr·ªã trung v·ªã
            median_val = df[df[col] != -1][col].median()
            df[col] = df[col].replace(-1, median_val)

    # Chuy·ªÉn ƒë·ªïi logarithm cho gi√°
    df['price_log'] = np.log1p(df['price_per_m2'])

    return df

# Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu pandas sang spark
@st.cache_resource
def convert_to_spark(data):
    """Chuy·ªÉn ƒë·ªïi DataFrame pandas sang DataFrame Spark."""
    spark = get_spark_session()
    return spark.createDataFrame(data)

# Hu·∫•n luy·ªán m√¥ h√¨nh
@st.cache_resource
def train_model(data):
    """Hu·∫•n luy·ªán m√¥ h√¨nh d·ª± ƒëo√°n gi√° b·∫•t ƒë·ªông s·∫£n."""
    # L∆∞u tr·ªØ t√™n c·ªôt g·ªëc ƒë·ªÉ s·ª≠ d·ª•ng cho d·ª± ƒëo√°n sau n√†y
    global FEATURE_COLUMNS

    # Ki·ªÉm tra c√°c c·ªôt c√≥ s·∫µn trong d·ªØ li·ªáu
    data_columns = data.columns

    # X√°c ƒë·ªãnh t√™n c·ªôt ƒë√∫ng cho c√°c ƒë·∫∑c tr∆∞ng s·ªë
    area_column = 'area_m2' if 'area_m2' in data_columns else 'area (m2)'
    street_column = 'street_width_m' if 'street_width_m' in data_columns else 'street (m)'

    # L∆∞u c·∫•u tr√∫c c·ªôt ƒë·ªÉ s·ª≠ d·ª•ng cho d·ª± ƒëo√°n
    FEATURE_COLUMNS = {
        'area': area_column,
        'street': street_column
    }

    # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu sang Spark DataFrame
    spark_df = convert_to_spark(data)

    # Chia d·ªØ li·ªáu th√†nh t·∫≠p hu·∫•n luy·ªán v√† ki·ªÉm tra
    train_df, test_df = spark_df.randomSplit([0.8, 0.2], seed=42)

    # Chu·∫©n b·ªã c√°c ƒë·∫∑c tr∆∞ng, s·ª≠ d·ª•ng t√™n c·ªôt th·ª±c t·∫ø
    numeric_features = [area_column, "bedroom_num", "floor_num", "toilet_num", "livingroom_num", street_column]

    # T·∫°o vector ƒë·∫∑c tr∆∞ng
    assembler = VectorAssembler(
        inputCols=numeric_features,
        outputCol="features"
    )

    # Chu·∫©n h√≥a ƒë·∫∑c tr∆∞ng
    scaler = StandardScaler(
        inputCol="features",
        outputCol="scaled_features",
        withStd=True,
        withMean=True
    )

    # M√¥ h√¨nh GBT Regressor
    gbt = GBTRegressor(
        featuresCol="scaled_features",
        labelCol="price_log",
        maxDepth=5,
        maxIter=100
    )

    # T·∫°o pipeline
    pipeline = Pipeline(stages=[assembler, scaler, gbt])

    # Hu·∫•n luy·ªán m√¥ h√¨nh
    model = pipeline.fit(train_df)

    # ƒê√°nh gi√° m√¥ h√¨nh
    predictions = model.transform(test_df)

    evaluator = RegressionEvaluator(
        labelCol="price_log",
        predictionCol="prediction",
        metricName="r2"
    )

    r2 = evaluator.evaluate(predictions)

    evaluator.setMetricName("rmse")
    rmse = evaluator.evaluate(predictions)

    return model, r2, rmse

# H√†m d·ª± ƒëo√°n gi√°
def predict_price(model, input_data):
    """D·ª± ƒëo√°n gi√° d·ª±a tr√™n ƒë·∫ßu v√†o c·ªßa ng∆∞·ªùi d√πng."""
    try:
        global FEATURE_COLUMNS

        # T·∫°o b·∫£n sao c·ªßa d·ªØ li·ªáu ƒë·∫ßu v√†o
        data_copy = input_data.copy()

        # ƒêi·ªÅu ch·ªânh t√™n c·ªôt ƒë·ªÉ ph√π h·ª£p v·ªõi m√¥ h√¨nh
        if hasattr(FEATURE_COLUMNS, 'get'):
            # ƒê·∫£m b·∫£o area_m2 v√† street_width_m ƒë∆∞·ª£c ƒë·ªïi t√™n ph√π h·ª£p
            if 'area_m2' in data_copy and FEATURE_COLUMNS.get('area') != 'area_m2':
                data_copy[FEATURE_COLUMNS['area']] = data_copy['area_m2']
                del data_copy['area_m2']

            if 'street_width_m' in data_copy and FEATURE_COLUMNS.get('street') != 'street_width_m':
                data_copy[FEATURE_COLUMNS['street']] = data_copy['street_width_m']
                del data_copy['street_width_m']
        else:
            # N·∫øu FEATURE_COLUMNS ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o, s·ª≠ d·ª•ng gi√° tr·ªã m·∫∑c ƒë·ªãnh
            # √Åp d·ª•ng mapping c≈© cho tr∆∞·ªùng h·ª£p n√†y
            column_mapping = {
                'area_m2': 'area (m2)',
                'street_width_m': 'street (m)'
            }
            for new_name, old_name in column_mapping.items():
                if new_name in data_copy and old_name not in data_copy:
                    data_copy[old_name] = data_copy[new_name]

        spark = get_spark_session()

        # In ra d·ªØ li·ªáu ƒë·∫ßu v√†o ƒë·ªÉ g·ª° l·ªói
        print("D·ªØ li·ªáu ƒë·∫ßu v√†o d·ª± ƒëo√°n:", data_copy)

        # T·∫°o DataFrame t·ª´ ƒë·∫ßu v√†o
        input_df = spark.createDataFrame([data_copy])

        # Th·ª±c hi·ªán d·ª± ƒëo√°n
        result = model.transform(input_df)

        # L·∫•y k·∫øt qu·∫£
        prediction_log = result.select("prediction").collect()[0][0]

        # Chuy·ªÉn t·ª´ gi√° tr·ªã logarithm sang gi√° tr·ªã th·∫≠t
        predicted_price = np.expm1(prediction_log)

        return predicted_price
    except Exception as e:
        # Ghi l·∫°i l·ªói ƒë·ªÉ g·ª° r·ªëi
        print(f"L·ªói khi d·ª± ƒëo√°n: {e}")
        st.error(f"C√≥ l·ªói x·∫£y ra khi d·ª± ƒëo√°n: {e}")
        return 0

# T·∫°o h√†m ƒë·ªÉ ch·∫°y ngrok
def run_ngrok():
    """K·∫øt n·ªëi ·ª©ng d·ª•ng Streamlit v·ªõi ngrok ƒë·ªÉ t·∫°o URL public."""
    # Thi·∫øt l·∫≠p ngrok - Ng∆∞·ªùi d√πng c·∫ßn nh·∫≠p authtoken
    st.sidebar.subheader("K·∫øt n·ªëi Ngrok")

    ngrok_auth_token = st.sidebar.text_input("Nh·∫≠p Ngrok Authtoken", type="password")

    if ngrok_auth_token:
        try:
            # Thi·∫øt l·∫≠p authtoken
            ngrok.set_auth_token(ngrok_auth_token)

            # T·∫°o tunnel HTTP ƒë·∫øn c·ªïng 8501 (c·ªïng m·∫∑c ƒë·ªãnh c·ªßa Streamlit)
            public_url = ngrok.connect(addr="8501", proto="http").public_url

            st.sidebar.success("‚úÖ Ngrok ƒë√£ k·∫øt n·ªëi th√†nh c√¥ng!")
            st.sidebar.markdown(f"**URL public:** {public_url}")
            st.sidebar.markdown("Chia s·∫ª URL n√†y ƒë·ªÉ ng∆∞·ªùi kh√°c c√≥ th·ªÉ truy c·∫≠p ·ª©ng d·ª•ng c·ªßa b·∫°n.")

            # L∆∞u URL v√†o session_state ƒë·ªÉ gi·ªØ gi√° tr·ªã gi·ªØa c√°c l·∫ßn ch·∫°y l·∫°i ·ª©ng d·ª•ng
            st.session_state["ngrok_url"] = public_url

        except Exception as e:
            st.sidebar.error(f"‚ùå L·ªói khi k·∫øt n·ªëi Ngrok: {e}")
    else:
        st.sidebar.info("‚ÑπÔ∏è Nh·∫≠p Ngrok Authtoken ƒë·ªÉ t·∫°o URL public. B·∫°n c√≥ th·ªÉ l·∫•y token mi·ªÖn ph√≠ t·∫°i [ngrok.com](https://ngrok.com).")

# T·∫£i d·ªØ li·ªáu
data = load_data()

# Ti·ªÅn x·ª≠ l√Ω d·ªØ li·ªáu
if not data.empty:
    processed_data = preprocess_data(data)

    # Hu·∫•n luy·ªán m√¥ h√¨nh
    with st.spinner("ƒêang hu·∫•n luy·ªán m√¥ h√¨nh d·ª± ƒëo√°n gi√°..."):
        model, r2_score, rmse = train_model(processed_data)

    # N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, hi·ªÉn th·ªã th√¥ng b√°o
else:
    st.error("Kh√¥ng th·ªÉ t·∫£i d·ªØ li·ªáu. Vui l√≤ng ki·ªÉm tra ƒë∆∞·ªùng d·∫´n ƒë·∫øn file d·ªØ li·ªáu.")
    st.stop()

# T·∫°o sidebar
st.sidebar.title("üè† Vietnam Real Estate")
app_mode = st.sidebar.selectbox("Ch·ªçn ch·∫ø ƒë·ªô", ["D·ª± ƒëo√°n gi√°", "Ph√¢n t√≠ch d·ªØ li·ªáu", "V·ªÅ d·ª± √°n"])

# K·∫øt n·ªëi Ngrok n·∫øu ng∆∞·ªùi d√πng ch·ªçn
if st.sidebar.checkbox("B·∫≠t k·∫øt n·ªëi Ngrok", False):
    run_ngrok()

# Hi·ªÉn th·ªã th√¥ng tin tr√™n sidebar
st.sidebar.subheader("Th√¥ng tin m√¥ h√¨nh")
st.sidebar.metric("ƒê·ªô ch√≠nh x√°c (R¬≤)", f"{r2_score:.4f}")
st.sidebar.metric("RMSE", f"{rmse:.4f}")
st.sidebar.metric("S·ªë l∆∞·ª£ng b·∫•t ƒë·ªông s·∫£n", f"{len(data):,}")

# Footer c·ªßa sidebar
st.sidebar.markdown("---")
st.sidebar.info(
    "D·ª± √°n D·ª± ƒëo√°n gi√° b·∫•t ƒë·ªông s·∫£n Vi·ªát Nam s·ª≠ d·ª•ng PySpark, Streamlit v√† Ngrok. "
    "D·ªØ li·ªáu ƒë∆∞·ª£c thu th·∫≠p t·ª´ nhadat.cafeland.vn."
)

# CH·∫æ ƒê·ªò 1: D·ª∞ ƒêO√ÅN GI√Å
if app_mode == "D·ª± ƒëo√°n gi√°":
    st.title("üèòÔ∏è D·ª± ƒëo√°n gi√° b·∫•t ƒë·ªông s·∫£n Vi·ªát Nam")
    st.markdown("### Nh·∫≠p th√¥ng tin v·ªÅ b·∫•t ƒë·ªông s·∫£n ƒë·ªÉ nh·∫≠n d·ª± ƒëo√°n gi√°")

    # T·∫°o layout v·ªõi 2 c·ªôt
    col1, col2 = st.columns(2)

    with col1:
        st.markdown("#### üìç V·ªã tr√≠")
        # T·∫°o card b·∫±ng c√°ch d√πng container v·ªõi CSS t√πy ch·ªânh
        with st.container():
            st.markdown('<div class="card">', unsafe_allow_html=True)

            # Ch·ªçn t·ªânh/th√†nh ph·ªë
            city_options = sorted(data["city_province"].unique())
            city = st.selectbox("T·ªânh/Th√†nh ph·ªë", city_options)

            # L·ªçc qu·∫≠n/huy·ªán d·ª±a tr√™n t·ªânh/th√†nh ph·ªë ƒë√£ ch·ªçn
            district_options = sorted(data[data["city_province"] == city]["district"].unique())
            district = st.selectbox("Qu·∫≠n/Huy·ªán", district_options)

            st.markdown('</div>', unsafe_allow_html=True)

        st.markdown("#### üè† ƒê·∫∑c ƒëi·ªÉm b·∫•t ƒë·ªông s·∫£n")
        with st.container():
            st.markdown('<div class="card">', unsafe_allow_html=True)

            # Th√¥ng tin c∆° b·∫£n v·ªÅ BƒêS
            area = st.number_input("Di·ªán t√≠ch (m¬≤)", min_value=10.0, max_value=1000.0, value=80.0, step=10.0)
            category_options = sorted(data["category"].unique())
            category = st.selectbox("Lo·∫°i b·∫•t ƒë·ªông s·∫£n", category_options)
            direction_options = sorted(data["direction"].unique())
            direction = st.selectbox("H∆∞·ªõng nh√†", direction_options)
            liability_options = sorted(data["liability"].unique())
            liability = st.selectbox("T√¨nh tr·∫°ng ph√°p l√Ω", liability_options)

            st.markdown('</div>', unsafe_allow_html=True)

    with col2:
        st.markdown("#### üö™ Th√¥ng tin ph√≤ng ·ªëc")
        with st.container():
            st.markdown('<div class="card">', unsafe_allow_html=True)

            # Th√¥ng tin ph√≤ng ·ªëc
            bedroom_num = st.number_input("S·ªë ph√≤ng ng·ªß", min_value=0, max_value=10, value=2, step=1)
            floor_num = st.number_input("S·ªë t·∫ßng", min_value=0, max_value=50, value=2, step=1)
            toilet_num = st.number_input("S·ªë nh√† v·ªá sinh", min_value=0, max_value=10, value=2, step=1)
            livingroom_num = st.number_input("S·ªë ph√≤ng kh√°ch", min_value=0, max_value=10, value=1, step=1)

            st.markdown('</div>', unsafe_allow_html=True)

        st.markdown("#### üõ£Ô∏è Th√¥ng tin khu v·ª±c")
        with st.container():
            st.markdown('<div class="card">', unsafe_allow_html=True)

            # Th√¥ng tin khu v·ª±c
            street_width = st.number_input("Chi·ªÅu r·ªông ƒë∆∞·ªùng (m)", min_value=0.0, max_value=50.0, value=8.0, step=0.5)

            st.markdown('</div>', unsafe_allow_html=True)

    # N√∫t d·ª± ƒëo√°n
    if st.button("D·ª± ƒëo√°n gi√°", type="primary"):
        # Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·∫ßu v√†o
        input_data = {
            "area_m2": area,
            "bedroom_num": bedroom_num,
            "floor_num": floor_num,
            "toilet_num": toilet_num,
            "livingroom_num": livingroom_num,
            "street_width_m": street_width,
            "city_province": city,
            "district": district,
            "category": category,
            "direction": direction,
            "liability": liability,
            # C√°c tr∆∞·ªùng c·∫ßn thi·∫øt cho m√¥ h√¨nh
            "price_per_m2": 0,  # Gi√° tr·ªã n√†y s·∫Ω b·ªã b·ªè qua trong d·ª± ƒëo√°n
            "price_log": 0      # Gi√° tr·ªã n√†y s·∫Ω b·ªã b·ªè qua trong d·ª± ƒëo√°n
        }

        # D·ª± ƒëo√°n gi√°
        with st.spinner("ƒêang d·ª± ƒëo√°n gi√°..."):
            try:
                # Th√™m hi·ªáu ·ª©ng ch·ªù ƒë·ªÉ c·∫£i thi·ªán UX
                progress_bar = st.progress(0)
                for percent_complete in range(0, 101, 20):
                    time.sleep(0.1)  # T·∫°o ƒë·ªô tr·ªÖ gi·∫£ ƒë·ªÉ hi·ªáu ·ª©ng ƒë·∫πp h∆°n
                    progress_bar.progress(percent_complete)
                progress_bar.empty()  # X√≥a thanh ti·∫øn tr√¨nh sau khi ho√†n th√†nh

                # Th·ª±c hi·ªán d·ª± ƒëo√°n
                predicted_price_per_m2 = predict_price(model, input_data)
                total_price = predicted_price_per_m2 * area

                # Hi·ªÉn th·ªã k·∫øt qu·∫£ trong container ƒë·∫πp
                st.markdown("#### üìä K·∫øt qu·∫£ d·ª± ƒëo√°n")
                with st.container():
                    st.markdown('<div class="card" style="background-color: #eaf7ea;">', unsafe_allow_html=True)

                    col1, col2 = st.columns(2)
                    with col1:
                        st.metric("Gi√° d·ª± ƒëo√°n / m¬≤", f"{predicted_price_per_m2:,.0f} VND")
                    with col2:
                        st.metric("T·ªïng gi√° d·ª± ƒëo√°n", f"{total_price:,.0f} VND")

                    # Hi·ªÉn th·ªã theo t·ª∑ VND cho d·ªÖ ƒë·ªçc
                    total_price_billion = total_price / 1e9
                    st.info(f"üí∞ T·ªïng gi√° d·ª± ƒëo√°n: **{total_price_billion:.2f} t·ª∑ VND**")

                    st.markdown('</div>', unsafe_allow_html=True)

                # Hi·ªÉn th·ªã c√°c b·∫•t ƒë·ªông s·∫£n t∆∞∆°ng t·ª±
                st.markdown("#### üîç B·∫•t ƒë·ªông s·∫£n t∆∞∆°ng t·ª±")
                similar_properties = data[
                    (data["city_province"] == city) &
                    (data["district"] == district) &
                    (data["area_m2"] > area * 0.7) &
                    (data["area_m2"] < area * 1.3)
                ]

                if len(similar_properties) > 0:
                    similar_df = similar_properties[["area_m2", "price_per_m2", "bedroom_num", "floor_num", "category"]].head(5).reset_index(drop=True)
                    similar_df.columns = ["Di·ªán t√≠ch (m¬≤)", "Gi√°/m¬≤ (VND)", "S·ªë ph√≤ng ng·ªß", "S·ªë t·∫ßng", "Lo·∫°i BƒêS"]
                    st.dataframe(similar_df, use_container_width=True)
                else:
                    st.info("Kh√¥ng t√¨m th·∫•y b·∫•t ƒë·ªông s·∫£n t∆∞∆°ng t·ª± trong d·ªØ li·ªáu.")

            except Exception as e:
                st.error(f"L·ªói khi d·ª± ƒëo√°n: {e}")

# CH·∫æ ƒê·ªò 2: PH√ÇN T√çCH D·ªÆ LI·ªÜU
elif app_mode == "Ph√¢n t√≠ch d·ªØ li·ªáu":
    st.title("üìä Ph√¢n t√≠ch d·ªØ li·ªáu b·∫•t ƒë·ªông s·∫£n Vi·ªát Nam")

    # T·∫°o tabs ƒë·ªÉ ph√¢n chia n·ªôi dung
    tab1, tab2, tab3 = st.tabs(["üìà Ph√¢n ph·ªëi gi√°", "üìç Ph√¢n t√≠ch v·ªã tr√≠", "üè† ƒê·∫∑c ƒëi·ªÉm b·∫•t ƒë·ªông s·∫£n"])

    with tab1:
        st.subheader("Ph√¢n t√≠ch ph√¢n ph·ªëi gi√° b·∫•t ƒë·ªông s·∫£n")

        # V·∫Ω bi·ªÉu ƒë·ªì ph√¢n ph·ªëi gi√°
        fig, ax = plt.subplots(1, 2, figsize=(14, 6))

        # Ph√¢n ph·ªëi gi√° ban ƒë·∫ßu
        sns.histplot(data["price_per_m2"], kde=True, ax=ax[0])
        ax[0].set_title("Ph√¢n ph·ªëi gi√° / m¬≤")
        ax[0].set_xlabel("Gi√° (VND/m¬≤)")
        ax[0].set_ylabel("S·ªë l∆∞·ª£ng")

        # Ph√¢n ph·ªëi gi√° sau khi bi·∫øn ƒë·ªïi log
        sns.histplot(np.log1p(data["price_per_m2"]), kde=True, ax=ax[1])
        ax[1].set_title("Ph√¢n ph·ªëi logarit c·ªßa gi√° / m¬≤")
        ax[1].set_xlabel("ln(Gi√°/m¬≤)")
        ax[1].set_ylabel("S·ªë l∆∞·ª£ng")

        plt.tight_layout()
        st.pyplot(fig)

        # T∆∞∆°ng t√°c: L·ªçc theo kho·∫£ng gi√°
        st.subheader("L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√°")

        # T·∫°o slider ch·ªçn kho·∫£ng gi√°
        price_range = st.slider(
            "Ch·ªçn kho·∫£ng gi√° (VND/m¬≤)",
            min_value=float(data["price_per_m2"].min()),
            max_value=float(data["price_per_m2"].max()),
            value=(float(data["price_per_m2"].quantile(0.25)), float(data["price_per_m2"].quantile(0.75)))
        )

        # L·ªçc d·ªØ li·ªáu theo kho·∫£ng gi√° ƒë√£ ch·ªçn
        filtered_data = data[(data["price_per_m2"] >= price_range[0]) & (data["price_per_m2"] <= price_range[1])]

        # Hi·ªÉn th·ªã th√¥ng tin v·ªÅ d·ªØ li·ªáu ƒë√£ l·ªçc
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("S·ªë l∆∞·ª£ng BƒêS", f"{len(filtered_data)}")
        with col2:
            st.metric("Gi√° trung b√¨nh/m¬≤", f"{filtered_data['price_per_m2'].mean():,.0f} VND")
        with col3:
            st.metric("Di·ªán t√≠ch trung b√¨nh", f"{filtered_data['area_m2'].mean():.1f} m¬≤")

        # Hi·ªÉn th·ªã d·ªØ li·ªáu ƒë√£ l·ªçc
        st.dataframe(filtered_data[["city_province", "district", "area_m2", "price_per_m2", "category"]].head(10))

    with tab2:
        st.subheader("Ph√¢n t√≠ch gi√° theo v·ªã tr√≠ ƒë·ªãa l√Ω")

        # Ph√¢n t√≠ch gi√° trung b√¨nh theo t·ªânh/th√†nh ph·ªë
        st.markdown("#### Gi√° trung b√¨nh theo t·ªânh/th√†nh ph·ªë")

        # T√≠nh gi√° trung b√¨nh theo t·ªânh/th√†nh ph·ªë
        city_price = data.groupby("city_province")["price_per_m2"].mean().sort_values(ascending=False).reset_index()
        city_price.columns = ["T·ªânh/Th√†nh ph·ªë", "Gi√° trung b√¨nh/m¬≤"]

        # V·∫Ω bi·ªÉu ƒë·ªì
        fig = px.bar(
            city_price.head(10),
            x="T·ªânh/Th√†nh ph·ªë",
            y="Gi√° trung b√¨nh/m¬≤",
            title="Top 10 t·ªânh/th√†nh ph·ªë c√≥ gi√° b·∫•t ƒë·ªông s·∫£n cao nh·∫•t",
            template="plotly_white"
        )
        st.plotly_chart(fig, use_container_width=True)

        # Ph√¢n t√≠ch gi√° theo qu·∫≠n/huy·ªán trong m·ªôt t·ªânh/th√†nh ph·ªë ƒë√£ ch·ªçn
        st.markdown("#### Gi√° trung b√¨nh theo qu·∫≠n/huy·ªán")

        # Ch·ªçn t·ªânh/th√†nh ph·ªë ƒë·ªÉ xem chi ti·∫øt
        selected_city = st.selectbox("Ch·ªçn t·ªânh/th√†nh ph·ªë", sorted(data["city_province"].unique()))

        # L·ªçc d·ªØ li·ªáu theo t·ªânh/th√†nh ph·ªë ƒë√£ ch·ªçn
        city_data = data[data["city_province"] == selected_city]

        # T√≠nh gi√° trung b√¨nh theo qu·∫≠n/huy·ªán
        district_price = city_data.groupby("district")["price_per_m2"].mean().sort_values(ascending=False).reset_index()
        district_price.columns = ["Qu·∫≠n/Huy·ªán", "Gi√° trung b√¨nh/m¬≤"]

        # V·∫Ω bi·ªÉu ƒë·ªì
        fig = px.bar(
            district_price,
            x="Qu·∫≠n/Huy·ªán",
            y="Gi√° trung b√¨nh/m¬≤",
            title=f"Gi√° b·∫•t ƒë·ªông s·∫£n trung b√¨nh theo qu·∫≠n/huy·ªán t·∫°i {selected_city}",
            template="plotly_white"
        )
        st.plotly_chart(fig, use_container_width=True)

    with tab3:
        st.subheader("Ph√¢n t√≠ch m·ªëi quan h·ªá gi·ªØa ƒë·∫∑c ƒëi·ªÉm v√† gi√°")

        # Bi·ªÉu ƒë·ªì ph√¢n t√°n: Di·ªán t√≠ch vs. Gi√°
        st.markdown("#### M·ªëi quan h·ªá gi·ªØa di·ªán t√≠ch v√† gi√°")

        # T·∫°o m·∫´u nh·ªè h∆°n n·∫øu c√≥ qu√° nhi·ªÅu d·ªØ li·ªáu
        sample_size = min(1000, len(data))
        sampled_data = data.sample(sample_size, random_state=42)

        # V·∫Ω bi·ªÉu ƒë·ªì ph√¢n t√°n
        fig = px.scatter(
            sampled_data,
            x="area_m2",
            y="price_per_m2",
            color="city_province",
            size="bedroom_num",
            hover_data=["district", "category"],
            title="M·ªëi quan h·ªá gi·ªØa di·ªán t√≠ch v√† gi√°",
            labels={
                "area_m2": "Di·ªán t√≠ch (m¬≤)",
                "price_per_m2": "Gi√°/m¬≤ (VND)",
                "city_province": "T·ªânh/Th√†nh ph·ªë",
                "bedroom_num": "S·ªë ph√≤ng ng·ªß"
            },
            template="plotly_white"
        )
        st.plotly_chart(fig, use_container_width=True)

        # Ma tr·∫≠n t∆∞∆°ng quan
        st.markdown("#### Ma tr·∫≠n t∆∞∆°ng quan gi·ªØa c√°c ƒë·∫∑c ƒëi·ªÉm s·ªë")

        # Ch·ªçn c√°c ƒë·∫∑c tr∆∞ng s·ªë ƒë·ªÉ t√≠nh t∆∞∆°ng quan
        numeric_features = ["area_m2", "bedroom_num", "floor_num", "toilet_num", "livingroom_num", "street_width_m", "price_per_m2"]
        corr_matrix = data[numeric_features].corr()

        # V·∫Ω heatmap t∆∞∆°ng quan
        fig, ax = plt.subplots(figsize=(10, 8))
        sns.heatmap(corr_matrix, annot=True, cmap="coolwarm", ax=ax, fmt=".2f")
        plt.title("Ma tr·∫≠n t∆∞∆°ng quan gi·ªØa c√°c ƒë·∫∑c ƒëi·ªÉm")
        st.pyplot(fig)

        # Ph√¢n t√≠ch theo ƒë·∫∑c ƒëi·ªÉm b·∫•t ƒë·ªông s·∫£n
        st.markdown("#### Ph√¢n t√≠ch gi√° theo ƒë·∫∑c ƒëi·ªÉm")

        # Ch·ªçn ƒë·∫∑c ƒëi·ªÉm ƒë·ªÉ ph√¢n t√≠ch
        feature = st.selectbox(
            "Ch·ªçn ƒë·∫∑c ƒëi·ªÉm",
            ["category", "direction", "liability", "bedroom_num", "floor_num"]
        )

        # T√≠nh gi√° trung b√¨nh theo ƒë·∫∑c ƒëi·ªÉm ƒë√£ ch·ªçn
        if feature in ["bedroom_num", "floor_num"]:
            # ƒê·ªëi v·ªõi ƒë·∫∑c ƒëi·ªÉm s·ªë, chuy·ªÉn ƒë·ªïi th√†nh chu·ªói ƒë·ªÉ nh√≥m
            data["feature_str"] = data[feature].astype(str)
            feature_price = data.groupby("feature_str")["price_per_m2"].mean().reset_index()
            feature_price.columns = [feature, "Gi√° trung b√¨nh/m¬≤"]

            # S·∫Øp x·∫øp theo th·ª© t·ª± s·ªë
            feature_price[feature] = feature_price[feature].astype(float)
            feature_price = feature_price.sort_values(by=feature)
            feature_price[feature] = feature_price[feature].astype(str)
        else:
            # ƒê·ªëi v·ªõi ƒë·∫∑c ƒëi·ªÉm ph√¢n lo·∫°i
            feature_price = data.groupby(feature)["price_per_m2"].mean().sort_values(ascending=False).reset_index()
            feature_price.columns = [feature, "Gi√° trung b√¨nh/m¬≤"]

        # V·∫Ω bi·ªÉu ƒë·ªì
        fig = px.bar(
            feature_price,
            x=feature,
            y="Gi√° trung b√¨nh/m¬≤",
            title=f"Gi√° trung b√¨nh theo {feature}",
            template="plotly_white"
        )
        st.plotly_chart(fig, use_container_width=True)

# CH·∫æ ƒê·ªò 3: V·ªÄ D·ª∞ √ÅN
else:
    st.title("‚ÑπÔ∏è V·ªÅ d·ª± √°n d·ª± ƒëo√°n gi√° b·∫•t ƒë·ªông s·∫£n Vi·ªát Nam")

    # Gi·ªõi thi·ªáu d·ª± √°n
    st.markdown("""
    ## üè† D·ª± ƒëo√°n gi√° b·∫•t ƒë·ªông s·∫£n Vi·ªát Nam

    ƒê√¢y l√† ·ª©ng d·ª•ng demo cho m√¥ h√¨nh d·ª± ƒëo√°n gi√° b·∫•t ƒë·ªông s·∫£n t·∫°i Vi·ªát Nam s·ª≠ d·ª•ng h·ªçc m√°y.
    ·ª®ng d·ª•ng ƒë∆∞·ª£c ph√°t tri·ªÉn nh∆∞ m·ªôt ph·∫ßn c·ªßa d·ª± √°n nghi√™n c·ª©u v·ªÅ ·ª©ng d·ª•ng d·ªØ li·ªáu l·ªõn
    trong ph√¢n t√≠ch th·ªã tr∆∞·ªùng b·∫•t ƒë·ªông s·∫£n.

    ### üõ†Ô∏è C√¥ng ngh·ªá s·ª≠ d·ª•ng

    - **Thu th·∫≠p d·ªØ li·ªáu**: Selenium, BeautifulSoup
    - **X·ª≠ l√Ω d·ªØ li·ªáu l·ªõn**: Apache Spark (PySpark)
    - **H·ªçc m√°y**: Gradient Boosted Trees, Random Forest, Linear Regression
    - **Giao di·ªán ng∆∞·ªùi d√πng**: Streamlit
    - **Tri·ªÉn khai**: Ngrok

    ### üìä B·ªô d·ªØ li·ªáu

    B·ªô d·ªØ li·ªáu g·ªìm th√¥ng tin v·ªÅ h∆°n {len(data):,} b·∫•t ƒë·ªông s·∫£n ƒë∆∞·ª£c thu th·∫≠p t·ª´ website nhadat.cafeland.vn, bao g·ªìm:

    - V·ªã tr√≠ (t·ªânh/th√†nh ph·ªë, qu·∫≠n/huy·ªán)
    - Di·ªán t√≠ch, s·ªë ph√≤ng, s·ªë t·∫ßng
    - ƒê·∫∑c ƒëi·ªÉm b·∫•t ƒë·ªông s·∫£n (lo·∫°i b·∫•t ƒë·ªông s·∫£n, h∆∞·ªõng nh√†...)
    - Gi√°/m¬≤

    ### üìù Quy tr√¨nh x·ª≠ l√Ω d·ªØ li·ªáu

    1. **Thu th·∫≠p d·ªØ li·ªáu**: S·ª≠ d·ª•ng web scraping ƒë·ªÉ thu th·∫≠p d·ªØ li·ªáu t·ª´ trang b·∫•t ƒë·ªông s·∫£n
    2. **L√†m s·∫°ch d·ªØ li·ªáu**: X·ª≠ l√Ω gi√° tr·ªã thi·∫øu, ƒë·ªãnh d·∫°ng l·∫°i c√°c tr∆∞·ªùng, x·ª≠ l√Ω ngo·∫°i l·ªá
    3. **K·ªπ thu·∫≠t ƒë·∫∑c tr∆∞ng**: T·∫°o c√°c ƒë·∫∑c tr∆∞ng m·ªõi, m√£ h√≥a ƒë·∫∑c tr∆∞ng ph√¢n lo·∫°i
    4. **Hu·∫•n luy·ªán m√¥ h√¨nh**: S·ª≠ d·ª•ng Gradient Boosted Trees ƒë·ªÉ d·ª± ƒëo√°n gi√°
    5. **ƒê√°nh gi√° m√¥ h√¨nh**: R¬≤ = {r2_score:.4f}, RMSE = {rmse:.4f}

    ### üë• Nh√≥m ph√°t tri·ªÉn

    D·ª± √°n ƒë∆∞·ª£c ph√°t tri·ªÉn b·ªüi nh√≥m sinh vi√™n ng√†nh Data Science:

    - MSSV: 1234567
    - MSSV: 1234568
    - MSSV: 1234569

    ### üì± H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng

    - S·ª≠ d·ª•ng thanh ƒëi·ªÅu h∆∞·ªõng b√™n tr√°i ƒë·ªÉ chuy·ªÉn ƒë·ªïi gi·ªØa c√°c ch·∫ø ƒë·ªô
    - Trong ph·∫ßn "D·ª± ƒëo√°n gi√°", nh·∫≠p th√¥ng tin b·∫•t ƒë·ªông s·∫£n ƒë·ªÉ nh·∫≠n d·ª± ƒëo√°n
    - Trong ph·∫ßn "Ph√¢n t√≠ch d·ªØ li·ªáu", kh√°m ph√° c√°c xu h∆∞·ªõng v√† m·∫´u trong d·ªØ li·ªáu
    - S·ª≠ d·ª•ng t√≠nh nƒÉng Ngrok ƒë·ªÉ chia s·∫ª ·ª©ng d·ª•ng v·ªõi ng∆∞·ªùi kh√°c
    """)

    # Th√™m h√¨nh ·∫£nh minh h·ªça
    st.image("https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Flag_of_Vietnam.svg/1200px-Flag_of_Vietnam.svg.png", width=300)

